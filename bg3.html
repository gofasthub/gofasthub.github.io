<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avian Egg Harvest: Forest Battle</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; user-select: none; }
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid white; border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        #hud { position: absolute; bottom: 20px; left: 20px; color: white; text-shadow: 1px 1px 2px black; font-size: 18px; }
        .bar-container { width: 200px; height: 20px; background: rgba(0,0,0,0.5); margin-top: 5px; border-radius: 10px; overflow: hidden; }
        #health-bar { width: 100%; height: 100%; background: #ff4444; transition: width 0.2s; }
        #stamina-bar { width: 100%; height: 100%; background: #44ff44; transition: width 0.2s; }
        #score-board { position: absolute; top: 20px; right: 20px; color: white; text-align: right; text-shadow: 1px 1px 2px black; }
        #menu, #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; pointer-events: auto; z-index: 10; }
        #game-over { display: none; background: rgba(50, 0, 0, 0.9); }
        h1 { font-size: 48px; margin-bottom: 10px; color: #44ff44; text-shadow: 0 0 10px #44ff44; }
        .btn { padding: 15px 30px; margin: 10px; font-size: 24px; background: #333; border: 2px solid #555; color: white; cursor: pointer; border-radius: 5px; transition: 0.3s; }
        .btn:hover { background: #555; border-color: #888; transform: scale(1.05); }
        .char-select { display: flex; gap: 20px; margin-bottom: 30px; }
        .char-card { background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; cursor: pointer; border: 2px solid transparent; width: 150px; text-align: center; }
        .char-card:hover, .char-card.selected { border-color: #44ff44; background: rgba(255,255,255,0.2); }
        .char-icon { font-size: 40px; margin-bottom: 10px; }
        #message-area { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); color: yellow; font-size: 24px; text-shadow: 2px 2px 4px black; opacity: 0; transition: opacity 0.5s; }
        #egg-status { display: none; position: absolute; top: 100px; right: 20px; color: #FFD700; font-weight: bold; font-size: 24px; text-shadow: 0 0 5px orange; animation: pulse 1s infinite; }
        #home-marker { position: absolute; width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 20px solid #00FFFF; transform: translate(-50%, -50%); display: none; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <div id="game-ui">
        <div id="crosshair"></div>
        <div id="home-marker"></div>
        <div id="score-board">
            <h2>Eggs Secured: <span id="score-count">0</span></h2>
            <h3>Enemies Defeated: <span id="kill-count">0</span></h3>
        </div>
        <div id="egg-status">CARRYING EGG! RETURN TO NEST!</div>
        <div id="hud">
            <div>Health</div>
            <div class="bar-container"><div id="health-bar"></div></div>
            <div>Energy</div>
            <div class="bar-container"><div id="stamina-bar"></div></div>
            <div style="margin-top: 10px; font-size: 14px; opacity: 0.8;">
                Controls: Mouse to Turn | W/S Pitch | Space/Shift Fly | Click Attack | E Harvest/Deposit
            </div>
        </div>
        <div id="message-area"></div>
    </div>

    <div id="menu">
        <h1>AVIAN ARENA</h1>
        <p>Choose your Bird</p>
        <div class="char-select">
            <div class="char-card selected" onclick="selectBird('hummingbird', this)">
                <div class="char-icon">‚ö°</div>
                <h3>Hummingbird</h3>
                <small>Fast, Agile, Fragile</small>
            </div>
            <div class="char-card" onclick="selectBird('eagle', this)">
                <div class="char-icon">ü¶Ö</div>
                <h3>Bald Eagle</h3>
                <small>Strong, Balanced</small>
            </div>
            <div class="char-card" onclick="selectBird('opium', this)">
                <div class="char-icon">üßô‚Äç‚ôÇÔ∏è</div>
                <h3>Opium Bird</h3>
                <small>Tank, Heavy Hitter</small>
            </div>
            <div class="char-card" onclick="selectBird('dodo', this)">
                <div class="char-icon">ü¶§</div>
                <h3>Dodo</h3>
                <small>Flightless(?), Tough</small>
            </div>
        </div>
        <button class="btn" onclick="startGame()">ENTER FOREST</button>
    </div>

    <div id="game-over">
        <h1 style="color: red;">YOU DIED</h1>
        <p id="death-stats"></p>
        <button class="btn" onclick="location.reload()">RESPAWN</button>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Configuration & Constants ---
        let scene, camera, renderer, clock;
        let player, world;
        let enemies = [];
        let nests = [];
        let particles = [];
        let isGameActive = false;
        
        const KEYS = {};
        const MOUSE = { x: 0, y: 0, locked: false };
        const MAP_SIZE = 600;

        const BIRD_STATS = {
            hummingbird: { speed: 30, turn: 3.0, health: 50, dmg: 10, scale: 0.5, color: 0x2ecc71, wingSpeed: 0.8 },
            eagle:       { speed: 20, turn: 2.0, health: 100, dmg: 25, scale: 1.2, color: 0x5D4037, wingSpeed: 0.3 },
            opium:       { speed: 12, turn: 1.5, health: 250, dmg: 40, scale: 2.5, color: 0xEEEEEE, wingSpeed: 0.1 },
            dodo:        { speed: 10,  turn: 1.5, health: 150, dmg: 15, scale: 1.0, color: 0x795548, wingSpeed: 0.4 }
        };

        let selectedBirdType = 'hummingbird';
        let score = { eggs: 0, kills: 0 };
        let homeNestPosition = new THREE.Vector3(0, 5, 0);

        // --- Setup ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1.2);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 500;
            scene.add(dirLight);

            // Clock
            clock = new THREE.Clock();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', e => KEYS[e.code] = true);
            document.addEventListener('keyup', e => KEYS[e.code] = false);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            
            // Pointer Lock
            renderer.domElement.addEventListener('click', () => {
                if(isGameActive) renderer.domElement.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => {
                MOUSE.locked = (document.pointerLockElement === renderer.domElement);
            });
        }

        // --- Game Logic ---

        function startGame() {
            document.getElementById('menu').style.display = 'none';
            isGameActive = true;
            createWorld();
            spawnPlayer();
            spawnEnemies(8); 
            renderer.domElement.requestPointerLock();
            animate();
        }

        function selectBird(type, el) {
            selectedBirdType = type;
            document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
            el.classList.add('selected');
        }

        function createWorld() {
            // 1. Ground
            const groundGeo = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE, 64, 64);
            const pos = groundGeo.attributes.position;
            for(let i=0; i<pos.count; i++){
                // Create some hills
                const x = pos.getX(i);
                const y = pos.getY(i); // This is Z in world space before rotation
                const z = Math.sin(x/50) * Math.cos(y/50) * 10 + Math.random() * 2;
                pos.setZ(i, z);
            }
            groundGeo.computeVertexNormals();
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32, roughness: 0.9 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // 2. Water (Lakes/Rivers)
            const waterGeo = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE);
            const waterMat = new THREE.MeshStandardMaterial({ color: 0x0077be, transparent: true, opacity: 0.8, roughness: 0.1 });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.y = 4; // Water level
            scene.add(water);

            // 3. Invisible Walls
            const wallGeo = new THREE.BoxGeometry(MAP_SIZE, 100, 1);
            const wallMat = new THREE.MeshBasicMaterial({ visible: false }); // Invisible
            const wall1 = new THREE.Mesh(wallGeo, wallMat); wall1.position.z = -MAP_SIZE/2; scene.add(wall1);
            const wall2 = new THREE.Mesh(wallGeo, wallMat); wall2.position.z = MAP_SIZE/2; scene.add(wall2);
            const wall3 = new THREE.Mesh(wallGeo, wallMat); wall3.position.x = -MAP_SIZE/2; wall3.rotation.y=Math.PI/2; scene.add(wall3);
            const wall4 = new THREE.Mesh(wallGeo, wallMat); wall4.position.x = MAP_SIZE/2; wall4.rotation.y=Math.PI/2; scene.add(wall4);


            // 4. Rocks
            for(let i=0; i<20; i++) {
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(Math.random() * 5 + 2),
                    new THREE.MeshStandardMaterial({ color: 0x757575 })
                );
                rock.position.set((Math.random()-0.5)*MAP_SIZE, 5, (Math.random()-0.5)*MAP_SIZE);
                rock.castShadow = true;
                scene.add(rock);
            }

            // 5. Trees & Nests
            for(let i=0; i<150; i++) {
                const x = (Math.random() - 0.5) * (MAP_SIZE - 20);
                const z = (Math.random() - 0.5) * (MAP_SIZE - 20);
                
                // Don't spawn trees in deep water roughly
                const isWater = Math.sin(x/50) * Math.cos(z/50) * 10 < 2; 
                if(!isWater) {
                    const treeData = createTree();
                    treeData.mesh.position.set(x, 0, z);
                    scene.add(treeData.mesh);

                    // Chance to spawn enemy nest
                    if(Math.random() < 0.3) {
                        const branchPos = treeData.branchPositions[Math.floor(Math.random() * treeData.branchPositions.length)];
                        // Convert local branch pos to world pos
                        const worldBranchPos = branchPos.clone().add(treeData.mesh.position);
                        createNest(worldBranchPos.x, worldBranchPos.y + 0.5, worldBranchPos.z, false);
                    }
                }
            }

            // 6. Home Nest (Player's Base)
            homeNestPosition.set(0, 15, 0); // Spawns near center on a dedicated structure
            const homeBase = createTree();
            homeBase.mesh.position.set(0,0,0);
            homeBase.mesh.scale.setScalar(1.5); // Big home tree
            scene.add(homeBase.mesh);
            createNest(0, 15, 0, true);
        }

        function createTree() {
            const group = new THREE.Group();
            
            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(0.8, 1.5, 15, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4E342E });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 7.5;
            trunk.castShadow = true;
            group.add(trunk);

            // Branches - Store positions for nests
            const branchPositions = [];
            const branchMat = new THREE.MeshStandardMaterial({ color: 0x4E342E });
            
            for(let i=0; i<4; i++) {
                const branch = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 6), branchMat);
                const angle = (i / 4) * Math.PI * 2;
                branch.position.set(0, 10 + Math.random()*2, 0);
                branch.rotation.z = Math.PI / 3; // angle up
                branch.rotation.y = angle;
                
                // Calculate tip position approximately for nest placement
                // This is a bit rough, simple trig for visual placement
                const tipX = Math.sin(angle) * 3;
                const tipZ = Math.cos(angle) * 3;
                const tipY = branch.position.y + 2; 

                // Offset cylinder center
                branch.position.x += Math.sin(angle) * 1.5;
                branch.position.z += Math.cos(angle) * 1.5;
                branch.position.y += 1;

                group.add(branch);
                branchPositions.push(new THREE.Vector3(tipX, tipY, tipZ));
            }

            // Leaves (Canopy) - Higher up to reveal branches
            const leavesGeo = new THREE.DodecahedronGeometry(6);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 16;
            leaves.castShadow = true;
            group.add(leaves);

            return { mesh: group, branchPositions: branchPositions };
        }

        function createNest(x, y, z, isHome) {
            const nestGeo = new THREE.TorusGeometry(1.5, 0.4, 8, 12);
            const color = isHome ? 0x00FFFF : 0x8D6E63;
            const nestMat = new THREE.MeshStandardMaterial({ color: color });
            const nest = new THREE.Mesh(nestGeo, nestMat);
            nest.position.set(x, y, z);
            nest.rotation.x = Math.PI / 2;
            nest.castShadow = true;
            scene.add(nest);

            if(isHome) {
                // Home Marker Beacon
                const beamGeo = new THREE.CylinderGeometry(0.1, 0.1, 100, 8);
                const beamMat = new THREE.MeshBasicMaterial({ color: 0x00FFFF, transparent: true, opacity: 0.3 });
                const beam = new THREE.Mesh(beamGeo, beamMat);
                beam.position.y = 50;
                nest.add(beam);
                
                // Store home location globally
                homeNestPosition.set(x, y, z);
                
                // Add collision trigger for deposit
                nest.userData = { isHome: true };
            } else {
                // Eggs
                const eggCount = Math.floor(Math.random() * 2) + 1;
                nest.userData = { eggs: eggCount, isHome: false };
                
                for(let i=0; i<eggCount; i++) {
                    const eggGeo = new THREE.SphereGeometry(0.4, 8, 8);
                    const eggMat = new THREE.MeshStandardMaterial({ color: 0xFFF9C4 });
                    const egg = new THREE.Mesh(eggGeo, eggMat);
                    egg.position.set((Math.random()-0.5), (Math.random()-0.5), 0);
                    egg.scale.y = 1.2;
                    nest.add(egg);
                }
            }
            nests.push(nest);
        }

        // --- Bird Generation ---

        function createBirdMesh(type) {
            const group = new THREE.Group();
            const matBody = new THREE.MeshStandardMaterial({ color: BIRD_STATS[type].color });
            const matBeak = new THREE.MeshStandardMaterial({ color: 0xFFC107 });
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const matWing = new THREE.MeshStandardMaterial({ color: BIRD_STATS[type].color, side: THREE.DoubleSide });

            let body, head, beak, lWing, rWing;

            // Simplified geometries for stability
            if (type === 'hummingbird') {
                body = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), matBody);
                body.scale.set(1, 2.5, 1); 
                body.rotation.x = Math.PI / 2;
                
                const wingGeo = new THREE.PlaneGeometry(1, 0.4);
                lWing = new THREE.Mesh(wingGeo, matWing);
                lWing.position.set(-0.6, 0, 0);
                rWing = new THREE.Mesh(wingGeo, matWing);
                rWing.position.set(0.6, 0, 0);
                
                head = new THREE.Group();
                beak = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.5, 4), new THREE.MeshStandardMaterial({color: 0x333333}));
                beak.rotation.x = -Math.PI/2;
                beak.position.z = 0.6;
                body.add(beak);

            } else if (type === 'eagle') {
                body = new THREE.Mesh(new THREE.ConeGeometry(0.8, 2.5, 8), matBody);
                body.rotation.x = Math.PI / 2;
                
                head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 8), matWhite);
                head.position.set(0, 0, 1.2); 
                body.add(head);

                beak = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.8, 4), matBeak);
                beak.rotation.x = -Math.PI / 2;
                beak.position.z = 0.5;
                head.add(beak);

                const wingGeo = new THREE.BoxGeometry(2.5, 0.1, 1);
                lWing = new THREE.Mesh(wingGeo, matBody);
                lWing.position.set(-1.5, 0, 0);
                rWing = new THREE.Mesh(wingGeo, matBody);
                rWing.position.set(1.5, 0, 0);

            } else if (type === 'opium') {
                body = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.2, 3, 8), matWhite);
                body.position.y = 0; 
                head = new THREE.Mesh(new THREE.SphereGeometry(0.9, 8, 8), matWhite);
                head.position.y = 1.5;
                body.add(head);
                beak = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.6, 4), matBeak);
                beak.rotation.x = -Math.PI / 2;
                beak.position.z = 0.8;
                head.add(beak);
                lWing = new THREE.Mesh(new THREE.SphereGeometry(0.5), matWhite);
                lWing.position.set(-1, 0.5, 0);
                rWing = new THREE.Mesh(new THREE.SphereGeometry(0.5), matWhite);
                rWing.position.set(1, 0.5, 0);

            } else if (type === 'dodo') {
                body = new THREE.Mesh(new THREE.SphereGeometry(1, 8, 8), matBody);
                head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 8), new THREE.MeshStandardMaterial({color: 0x555555}));
                head.position.set(0, 0.8, 0.6);
                body.add(head);
                beak = new THREE.Mesh(new THREE.ConeGeometry(0.3, 1, 4), new THREE.MeshStandardMaterial({color: 0x333333}));
                beak.rotation.x = -Math.PI / 2 + 0.5;
                beak.position.z = 0.5;
                head.add(beak);
                const wingGeo = new THREE.PlaneGeometry(0.8, 0.5);
                lWing = new THREE.Mesh(wingGeo, matBody);
                lWing.position.set(-0.9, 0, 0);
                rWing = new THREE.Mesh(wingGeo, matBody);
                rWing.position.set(0.9, 0, 0);
            }

            group.add(body);
            
            const lPivot = new THREE.Group(); lPivot.add(lWing); group.add(lPivot);
            const rPivot = new THREE.Group(); rPivot.add(rWing); group.add(rPivot);

            if(type === 'opium') {
               lPivot.position.set(0, 0.5, 0);
               rPivot.position.set(0, 0.5, 0);
            } else {
               lPivot.position.x = -0.2;
               rPivot.position.x = 0.2;
            }

            // Egg Carry Container
            const carryPoint = new THREE.Group();
            carryPoint.position.set(0, -0.5, 0);
            group.add(carryPoint);

            group.userData = { lPivot, rPivot, type, carryPoint };
            group.castShadow = true;
            group.traverse(o => { if(o.isMesh) o.castShadow = true; });

            return group;
        }

        // --- Classes ---

        class Entity {
            constructor(type, x, y, z) {
                this.type = type;
                this.stats = { ...BIRD_STATS[type] };
                this.mesh = createBirdMesh(type);
                this.mesh.scale.setScalar(this.stats.scale);
                this.mesh.position.set(x, y, z);
                scene.add(this.mesh);
                
                this.velocity = new THREE.Vector3();
                this.health = this.stats.health;
                this.maxHealth = this.stats.health;
                this.dead = false;
                this.wingPhase = Math.random();
            }

            animateWings(delta, speedMultiplier = 1) {
                if(this.dead) return;
                this.wingPhase += delta * 15 * this.stats.wingSpeed * speedMultiplier;
                const angle = Math.sin(this.wingPhase) * 0.5;
                this.mesh.userData.lPivot.rotation.z = angle;
                this.mesh.userData.rPivot.rotation.z = -angle;
            }

            takeDamage(amount) {
                this.health -= amount;
                if(this.health <= 0) this.die();
                this.mesh.traverse(c => {
                    if(c.isMesh) {
                        c.material.emissive.setHex(0xff0000);
                        setTimeout(() => c.material.emissive.setHex(0x000000), 100);
                    }
                });
            }

            die() {
                this.dead = true;
                scene.remove(this.mesh);
                createExplosion(this.mesh.position, this.stats.color);
            }
        }

        class Player extends Entity {
            constructor(type) {
                super(type, homeNestPosition.x + 2, homeNestPosition.y + 2, homeNestPosition.z);
                this.cameraOffset = new THREE.Vector3(0, 2, -5);
                this.yaw = 0;
                this.pitch = 0;
                this.energy = 100;
                this.carryingEgg = false;
            }

            update(delta) {
                if(this.dead) return;

                // Mouse Input (Rotation)
                if(MOUSE.locked) {
                    this.yaw -= MOUSE.x * 0.002;
                    this.pitch -= MOUSE.y * 0.002;
                    this.pitch = Math.max(-1.5, Math.min(1.5, this.pitch));
                }
                MOUSE.x = 0; MOUSE.y = 0;

                // Keyboard Input (Movement)
                const speed = this.stats.speed * (KEYS['ShiftLeft'] ? 2 : 1);
                const forward = new THREE.Vector3(0, 0, 1).applyEuler(new THREE.Euler(this.pitch, this.yaw, 0));
                
                if (KEYS['KeyW']) this.velocity.add(forward.multiplyScalar(speed * delta));
                if (KEYS['KeyS']) this.velocity.sub(forward.multiplyScalar(speed * delta * 0.5));
                
                // Flight physics
                if (KEYS['Space']) {
                    this.velocity.y += 20 * delta;
                    this.energy = Math.max(0, this.energy - 10 * delta);
                }
                
                // Gravity / Drag
                this.velocity.y -= 9.8 * delta * 0.5; 
                this.velocity.multiplyScalar(0.95);

                // Heavy birds physics
                if(this.type === 'opium' || this.type === 'dodo') {
                    if(this.mesh.position.y > 5 && !KEYS['Space']) this.velocity.y -= 20 * delta;
                }

                // Apply Move
                this.mesh.position.add(this.velocity.clone().multiplyScalar(delta));
                
                // Map Boundaries
                const limit = MAP_SIZE/2 - 5;
                this.mesh.position.x = Math.max(-limit, Math.min(limit, this.mesh.position.x));
                this.mesh.position.z = Math.max(-limit, Math.min(limit, this.mesh.position.z));
                if(this.mesh.position.y < 1) { this.mesh.position.y = 1; this.velocity.y = 0; }

                // Sync Mesh
                this.mesh.rotation.y = this.yaw + Math.PI; 
                this.mesh.rotation.x = this.pitch;

                // Camera Follow
                const camPos = this.mesh.position.clone().add(
                    new THREE.Vector3(0, 3 * this.stats.scale, -6 * this.stats.scale).applyEuler(new THREE.Euler(this.pitch, this.yaw, 0))
                );
                camera.position.lerp(camPos, 0.1);
                camera.lookAt(this.mesh.position.clone().add(new THREE.Vector3(0,0,10).applyEuler(new THREE.Euler(this.pitch, this.yaw, 0))));

                this.animateWings(delta, this.velocity.length() * 0.1);

                // Interactions
                if(KEYS['KeyE']) this.tryInteract();

                // UI Updates
                document.getElementById('health-bar').style.width = (this.health / this.maxHealth * 100) + '%';
                document.getElementById('stamina-bar').style.width = this.energy + '%';
                if(!KEYS['Space']) this.energy = Math.min(100, this.energy + 20 * delta);

                this.updateHomeMarker();
            }

            updateHomeMarker() {
                const homeMarker = document.getElementById('home-marker');
                
                if(!this.carryingEgg) {
                    homeMarker.style.display = 'none';
                    return;
                }

                homeMarker.style.display = 'block';

                // Simple screen projection for marker
                const target = homeNestPosition.clone();
                // Project 3D position to 2D screen space
                const vector = target.project(camera);

                // Convert to CSS coordinates
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;

                // Clamp to screen edges if behind camera
                if (vector.z > 1) {
                     // Behind camera, just hide or flip? hiding is simpler for now or handle edge case
                     homeMarker.style.display = 'none'; 
                } else {
                    homeMarker.style.left = x + 'px';
                    homeMarker.style.top = y + 'px';
                }
            }

            attack() {
                const attackRange = 8 * this.stats.scale;
                const attackDir = new THREE.Vector3(0,0,1).applyEuler(this.mesh.rotation);
                
                enemies.forEach(enemy => {
                    if(enemy.dead) return;
                    const dist = this.mesh.position.distanceTo(enemy.mesh.position);
                    if(dist < attackRange) {
                        const toEnemy = enemy.mesh.position.clone().sub(this.mesh.position).normalize();
                        if(attackDir.dot(toEnemy) > 0.5) {
                            enemy.takeDamage(this.stats.dmg);
                            showMessage("Hit!");
                        }
                    }
                });
            }

            tryInteract() {
                // Check Nests
                let handled = false;
                nests.forEach(nest => {
                    if(this.mesh.position.distanceTo(nest.position) < 8) {
                        // Deposit at Home
                        if(nest.userData.isHome && this.carryingEgg) {
                            this.depositEgg();
                            handled = true;
                        }
                        // Steal from Enemy
                        else if(!nest.userData.isHome && !this.carryingEgg && nest.userData.eggs > 0) {
                            this.stealEgg(nest);
                            handled = true;
                        }
                    }
                });
            }

            stealEgg(nest) {
                nest.userData.eggs--;
                const visualEgg = nest.children.find(c => c.geometry.type === 'SphereGeometry' && c.visible);
                if(visualEgg) visualEgg.visible = false;
                
                this.carryingEgg = true;
                document.getElementById('egg-status').style.display = 'block';
                showMessage("Egg Stolen! Return to Base!");

                // Add visual egg to bird
                const eggGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const eggMat = new THREE.MeshStandardMaterial({ color: 0xFFF9C4 });
                const carriedEgg = new THREE.Mesh(eggGeo, eggMat);
                this.mesh.userData.carryPoint.add(carriedEgg);
            }

            depositEgg() {
                this.carryingEgg = false;
                document.getElementById('egg-status').style.display = 'none';
                score.eggs++;
                document.getElementById('score-count').innerText = score.eggs;
                showMessage("Egg Secured!");

                // Remove visual egg
                this.mesh.userData.carryPoint.clear();
            }
        }

        class AI extends Entity {
            constructor(type) {
                const x = (Math.random()-0.5) * (MAP_SIZE - 50);
                const z = (Math.random()-0.5) * (MAP_SIZE - 50);
                super(type, x, 20 + Math.random()*20, z);
                this.state = 'wander';
                this.targetPos = new THREE.Vector3();
                this.pickNewTarget();
                this.attackCooldown = 0;
            }

            pickNewTarget() {
                this.targetPos.set(
                    (Math.random()-0.5) * (MAP_SIZE - 50),
                    10 + Math.random() * 40,
                    (Math.random()-0.5) * (MAP_SIZE - 50)
                );
            }

            update(delta) {
                if(this.dead) return;

                const distToPlayer = this.mesh.position.distanceTo(player.mesh.position);

                // State Machine
                if (distToPlayer < 60 && !player.dead) {
                    this.state = 'chase';
                } else {
                    this.state = 'wander';
                }

                let desiredVelocity = new THREE.Vector3();

                if (this.state === 'wander') {
                    if (this.mesh.position.distanceTo(this.targetPos) < 10) {
                        this.pickNewTarget();
                    }
                    desiredVelocity = this.targetPos.clone().sub(this.mesh.position).normalize().multiplyScalar(this.stats.speed * 0.5);
                } else if (this.state === 'chase') {
                    desiredVelocity = player.mesh.position.clone().sub(this.mesh.position).normalize().multiplyScalar(this.stats.speed * 0.8);
                    
                    if (distToPlayer < 8 && this.attackCooldown <= 0) {
                        player.takeDamage(this.stats.dmg);
                        this.attackCooldown = 1.0;
                        showMessage("Ouch!");
                    }
                }

                this.attackCooldown -= delta;
                this.velocity.lerp(desiredVelocity, delta * 2);
                this.mesh.position.add(this.velocity.clone().multiplyScalar(delta));

                // Collision with ground/water
                if(this.mesh.position.y < 4) this.mesh.position.y = 4;

                if(this.velocity.length() > 0.1) {
                    const lookTarget = this.mesh.position.clone().add(this.velocity);
                    this.mesh.lookAt(lookTarget);
                }
                this.animateWings(delta);
            }
        }

        function spawnPlayer() {
            if(player) scene.remove(player.mesh);
            player = new Player(selectedBirdType);
        }

        function spawnEnemies(count) {
            const types = ['hummingbird', 'eagle', 'opium', 'dodo'];
            for(let i=0; i<count; i++) {
                const type = types[Math.floor(Math.random() * types.length)];
                const enemy = new AI(type);
                enemies.push(enemy);
            }
        }

        // --- Visual Effects ---

        function createExplosion(pos, color) {
            for(let i=0; i<10; i++) {
                const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.userData = {
                    vel: new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10),
                    life: 1.0
                };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function updateParticles(delta) {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel.clone().multiplyScalar(delta));
                p.userData.life -= delta;
                p.scale.setScalar(p.userData.life);
                if(p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        function showMessage(text) {
            const el = document.getElementById('message-area');
            el.innerText = text;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 1500);
        }

        function onMouseDown(e) {
            if(!isGameActive || player.dead) return;
            if(e.button === 0) player.attack();
        }
        
        function onMouseMove(e) {
            if(MOUSE.locked) {
                MOUSE.x = e.movementX;
                MOUSE.y = e.movementY;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isGameActive) return;

            const delta = clock.getDelta();

            if(!player.dead) player.update(delta);
            
            enemies.forEach((e, index) => {
                e.update(delta);
                if(e.dead) {
                    enemies.splice(index, 1);
                    score.kills++;
                    document.getElementById('kill-count').innerText = score.kills;
                    if(enemies.length < 5) spawnEnemies(1);
                }
            });

            updateParticles(delta);

            if(player.health <= 0 && !player.dead) {
                player.die();
                document.exitPointerLock();
                const gameOver = document.getElementById('game-over');
                document.getElementById('death-stats').innerText = `Eggs Secured: ${score.eggs} | Birds Defeated: ${score.kills}`;
                gameOver.style.display = 'flex';
            }

            renderer.render(scene, camera);
        }

        // Start
        init();

    </script>
</body>
</html>
